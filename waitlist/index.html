<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>fedDSP — join the waitlist</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Favicons -->
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/favicon-32.png" sizes="32x32">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">

  <!-- Bootstrap + Fonts -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="preload" href="/FedDSPCustomFont.otf" as="font" type="font/otf" crossorigin>

  <!-- Plausible -->
  <script async src="https://plausible.io/js/pa-J3F9V_aWzkP06lWawfHxV.js"></script>
  <script>
    window.plausible = window.plausible || function () { (plausible.q = plausible.q || []).push(arguments) };
    plausible.init = plausible.init || function (i) { plausible.o = i || {} };
    plausible.init();
  </script>

  <style>
    :root {
      --brand-pink: #d466ad;
      /* original accent if needed */
      --accent-pink: #de54af;
      /* on-active (from new file) */
      --error-red: #E53024;
      /* error */
      --panel-radius: 28px;
      --glow-x: 50%;
      --glow-y: 50%;

      /* new-file base neutrals for inputs */
      --fdsp-white-30: rgba(255, 255, 255, .3);
      --fdsp-white-40: rgba(255, 255, 255, .4);
    }

    @font-face {
      font-family: 'FedDSPHeader';
      src: url('/FedDSPCustomFont.otf') format('opentype');
      font-display: swap;
    }

    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: 'Montserrat', Arial, sans-serif;
      overflow-x: hidden;
      /* keep scroll if needed */
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
    }

    h1,
    h2 {
      font-family: 'FedDSPHeader', sans-serif;
      line-height: .9;
      letter-spacing: .04em;
      font-size: 2.5rem;
    }

    /* Background layers: particle canvas + aurora */
    #background-canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      display: block;
    }

    #aurora {
      position: fixed;
      inset: -25%;
      z-index: -1;
      pointer-events: none;
      opacity: .18;
      background:
        radial-gradient(1200px 900px at 25% 40%, rgba(222, 84, 175, .45), rgba(222, 84, 175, 0) 60%),
        radial-gradient(1000px 800px at 70% 65%, rgba(255, 180, 230, .25), rgba(255, 180, 230, 0) 65%);
      transform: translate3d(0, 0, 0);
      animation: auroraDrift 200s linear infinite alternate;
      will-change: transform;
    }

    @keyframes auroraDrift {
      from {
        transform: translate3d(0, 0, 0);
      }

      to {
        transform: translate3d(200px, -200px, 0);
      }
    }

    .wrap {
      min-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      position: relative;
      z-index: 0;
    }

    .card-hold {
      border-radius: var(--panel-radius);
      background:
        radial-gradient(600px 600px at var(--glow-x) var(--glow-y),
          color-mix(in oklab, #fff 12%, transparent) 0%,
          transparent 65%),
        rgba(20, 20, 20, .92);
      border: 1px solid rgba(255, 255, 255, .08);
      box-shadow: 0 0 40px rgba(255, 255, 255, .14), 0 30px 90px rgba(0, 0, 0, .6);
      transition: transform .2s ease, box-shadow .2s ease, background-position .1s;
      padding-bottom: calc(2rem + 12px) !important;
      /* breathing room for errors */
    }

    .card-hold:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 52px rgba(255, 255, 255, .16), 0 42px 120px rgba(0, 0, 0, .65);
    }

    .logo {
      max-height: 72px;
    }

    .lead-muted {
      color: #bbb;
    }

    .form-row {
      max-width: 980px;
      margin-inline: auto;
      --bs-gutter-x: .6rem;
      --bs-gutter-y: .6rem;
    }

    /* Inputs: keep dark base, but adopt NEW FILE's on-active glow */
    .waitlist-input {
      background: rgba(255, 255, 255, .02);
      color: #fff !important;
      border: 2px solid var(--fdsp-white-30);
      /* stronger base border */
      padding: .9rem 1.1rem;
      border-radius: 999px;
      /* keep your pill shape */
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .06);
      transition: border-color .18s ease, box-shadow .18s ease, background-color .18s ease;
    }

    .waitlist-input::placeholder {
      color: var(--fdsp-white-40) !important;
      opacity: 1;
    }

    .waitlist-input:focus,
    .waitlist-input:focus-visible {
      outline: none;
      border-color: var(--accent-pink);
      background: rgba(255, 255, 255, .03);
      /* pink bloom from the new file */
      box-shadow:
        0 0 28px 6px rgba(222, 84, 175, .42),
        0 0 10px 2px rgba(222, 84, 175, .55),
        0 0 1px 0 var(--accent-pink) inset,
        inset 0 0 0 1px rgba(255, 255, 255, .08);
    }

    /* Submit button (keep your current style) */
    .waitlist-btn {
      position: relative;
      overflow: hidden;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: .25rem;
      border: 1px solid var(--accent-pink);
      background: var(--accent-pink);
      color: #000;
      font-weight: 700;
      border-radius: 24px;
      padding: .9rem 1.4rem;
      line-height: 1;
      box-shadow: none;
      transition: background .2s, color .2s, filter .15s;
    }

    .waitlist-btn:hover,
    .waitlist-btn:focus {
      background: #fff;
      color: #000;
    }

    .waitlist-btn .shine {
      position: absolute;
      inset: -40% -10%;
      background: radial-gradient(120px 80px at var(--mx, 50%) var(--my, 50%), rgba(255, 255, 255, .55), transparent 60%);
      mix-blend-mode: soft-light;
      pointer-events: none;
      opacity: .9;
      transition: opacity .2s;
    }

    /* Validation: only invalid (no green) */
    .waitlist-input.is-invalid {
      box-shadow:
        inset 0 0 0 2px color-mix(in oklab, var(--error-red) 65%, transparent),
        0 0 0 0 rgba(0, 0, 0, 0);
      border-color: var(--error-red);
    }

    .waitlist-input.is-valid {
      box-shadow: none;
    }

    /* Keep columns aligned: reserve space for one-line error always */
    .form-row .form-field {
      display: flex;
      flex-direction: column;
    }

    /* Always occupy space; only toggle visibility */
    .form-field .invalid-tooltip {
      position: static;
      transform: none;
      display: block;
      /* always in flow */
      visibility: hidden;
      /* hidden by default */
      min-height: 1.1rem;
      /* reserve vertical space (≈ one line) */
      margin-top: .375rem;
      margin-bottom: 0;
      /* no extra push on show */
      background: transparent;
      color: var(--error-red);
      box-shadow: none;
      padding: 0;
      white-space: normal;
      text-align: center;
      font-size: .95rem;
    }

    /* Show text when invalid */
    .waitlist-input.is-invalid+.invalid-tooltip {
      visibility: visible;
    }
  </style>
</head>

<body>
  <!-- Background sparkles + aurora -->
  <canvas id="background-canvas" aria-hidden="true"></canvas>
  <div id="aurora" aria-hidden="true"></div>

  <div class="wrap">
    <div class="container">
      <div class="row justify-content-center">
        <div class="col-12 col-md-12 col-lg-10 col-xl-9 col-xxl-8">
          <div class="card-hold p-4 p-md-5 text-center" id="hoverCard">
            <img class="logo mb-3" src="/fedDSP_logo_text_small_WonB.png" alt="fedDSP">
            <p class="lead-muted mb-4">join the waiting list:</p>

            <!-- Waitlist form -->
            <form id="waitlistForm" action="https://formspree.io/f/mpwyejge" method="POST" novalidate>
              <div class="row form-row gx-2 gy-2 justify-content-center align-items-start">
                <div class="col-12 col-md-6 position-relative form-field">
                  <input type="email" name="email" class="form-control waitlist-input" placeholder="your@email.com"
                    required autocomplete="email" inputmode="email">
                  <div class="invalid-tooltip">Enter a valid email address.</div>
                </div>

                <div class="col-12 col-md-4 position-relative form-field">
                  <input type="text" name="name" class="form-control waitlist-input" placeholder="your name" required>
                  <div class="invalid-tooltip">Please tell us your name.</div>
                </div>

                <div class="col-12 col-md-2">
                  <button type="submit" class="btn btn-lg waitlist-btn w-100">
                    JOIN
                    <span class="shine" aria-hidden="true"></span>
                  </button>
                </div>
              </div>

              <input type="text" name="_gotcha" style="display:none">
            </form>

            <!-- Inline thank-you (no redirect) -->
            <div class="success-msg mt-4" id="successMsg" hidden>
              <h2 class="mb-2">Thanks - you're on the list.</h2>
              <p class="lead-muted mb-0">We'll email only for launch updates. Unsubscribe anytime.</p>
            </div>
            <div class="error-msg mt-3" id="errorMsg" hidden>Something went wrong. Please try again.</div>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        const form = document.getElementById('waitlistForm');
        const ok = document.getElementById('successMsg');
        const err = document.getElementById('errorMsg');
        if (!form) return;

        // Initial state
        ok.hidden = true; err.hidden = true;

        form.querySelectorAll('input').forEach(el => {
          // While typing: don't show errors; clear any existing one
          el.addEventListener('input', () => {
            el.setCustomValidity('');
            el.classList.remove('is-invalid');
            err.hidden = true; // clear global error on user action
          }, { passive: true });

          // When user leaves the field: validate and show error if needed
          el.addEventListener('blur', () => {
            el.classList.toggle('is-invalid', !el.checkValidity());
          }, { passive: true });
        });

        form.addEventListener('submit', async (e) => {
          // Final gate: validate all fields
          if (!form.checkValidity()) {
            e.preventDefault();
            form.querySelectorAll('input').forEach(el => {
              el.classList.toggle('is-invalid', !el.checkValidity());
            });
            const firstBad = form.querySelector('input.is-invalid');
            if (firstBad) firstBad.focus();
            return;
          }

          e.preventDefault();
          ok.hidden = true; err.hidden = true;

          const data = new FormData(form);
          try {
            const res = await fetch(form.action, {
              method: 'POST', body: data, headers: { 'Accept': 'application/json' }
            });

            if (res.ok) {
              form.style.display = 'none';
              ok.hidden = false;
            } else {
              let msg = 'Something went wrong. Please try again.';
              try {
                const json = await res.json();
                if (json?.errors?.length) msg = json.errors.map(e => e.message).join(' ');
              } catch { }
              err.textContent = msg;
              err.hidden = false;
            }
          } catch {
            err.textContent = 'Network error. Please try again.';
            err.hidden = false;
          }
        });
      })();


      /* Panel glow follows cursor (keep) */
      (() => {
        const card = document.getElementById('hoverCard');
        let mx = innerWidth / 2, my = innerHeight / 2;
        addEventListener('pointermove', e => {
          mx = e.clientX; my = e.clientY;
          const r = card.getBoundingClientRect();
          const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
          const gx = clamp(((mx - r.left) / r.width) * 100, 0, 100);
          const gy = clamp(((my - r.top) / r.height) * 100, 0, 100);
          card.style.setProperty('--glow-x', gx + '%');
          card.style.setProperty('--glow-y', gy + '%');
        }, { passive: true });
      })();

      /* Button shine hotspot (keep) */
      (() => {
        const btn = document.querySelector('.waitlist-btn');
        if (!btn) return;
        btn.addEventListener('pointermove', e => {
          const r = btn.getBoundingClientRect();
          const x = ((e.clientX - r.left) / r.width * 100).toFixed(2) + '%';
          const y = ((e.clientY - r.top) / r.height * 100).toFixed(2) + '%';
          btn.style.setProperty('--mx', x);
          btn.style.setProperty('--my', y);
        }, { passive: true });
      })();

      /* ===== Featherweight particle “sparkles” background (from new file) ===== */
      (() => {
        const canvas = document.getElementById('background-canvas');
        const ctx = canvas.getContext('2d', { alpha: true });

        const DPR = Math.max(1, Math.min(1.5, window.devicePixelRatio || 1));
        let W = 0, H = 0;

        const mouse = { x: 0, y: 0, active: false, radius: 110 };
        let particles = [];
        const LINK_DIST = 170;
        const LINK_DIST2 = LINK_DIST * LINK_DIST;

        function resize() {
          W = Math.floor(window.innerWidth);
          H = Math.floor(window.innerHeight);
          canvas.width = Math.floor(W * DPR);
          canvas.height = Math.floor(H * DPR);
          canvas.style.width = W + 'px';
          canvas.style.height = H + 'px';
          ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
          initParticles();
        }

        function initParticles() {
          const area = W * H;
          const N = Math.min(140, Math.max(80, Math.round(area / 17000)));
          particles = [];
          for (let i = 0; i < N; i++) {
            particles.push({
              x: Math.random() * W,
              y: Math.random() * H,
              vx: (Math.random() - 0.5) * 0.4,
              vy: (Math.random() - 0.5) * 0.4,
              size: 1 + Math.random() * 1.1,
              seed: Math.random() * 1000
            });
          }
        }

        function flow(x, y, t) {
          const a = Math.sin(0.0023 * x + 0.0017 * y + 0.7 * t);
          const b = Math.cos(0.0019 * x - 0.0021 * y - 0.6 * t);
          const c = Math.sin(0.0011 * y - 0.0013 * x + 0.5 * t);
          return [a + c * 0.6, b - c * 0.6];
        }

        let last = performance.now();
        function loop(now) {
          const dt = Math.min(0.04, (now - last) / 1000);
          last = now;
          const t = now * 0.0012;

          ctx.clearRect(0, 0, W, H);

          // Update & draw dots
          for (let p of particles) {
            const [fx, fy] = flow(p.x + p.seed, p.y - p.seed, t);
            p.vx += fx * 0.02 * dt * 60;
            p.vy += fy * 0.02 * dt * 60;

            if (mouse.active) {
              const dx = p.x - mouse.x, dy = p.y - mouse.y;
              const dist = Math.hypot(dx, dy), R = mouse.radius * 1.1;
              if (dist < R && dist > 0.01) {
                const f = (1 - dist / R) * 0.06;
                p.vx += (dx / dist) * f;
                p.vy += (dy / dist) * f;
              }
            }

            p.vx *= 0.988; p.vy *= 0.988;
            const sp = Math.hypot(p.vx, p.vy), maxSp = 1.0;
            if (sp > maxSp) { const s = maxSp / sp; p.vx *= s; p.vy *= s; }

            p.x += p.vx; p.y += p.vy;

            if (p.x < 0 || p.x > W) p.vx *= -1, p.x = Math.max(0, Math.min(W, p.x));
            if (p.y < 0 || p.y > H) p.vy *= -1, p.y = Math.max(0, Math.min(H, p.y));

            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.fill();
          }

          if (mouse.active) { drawLines(t); }

          requestAnimationFrame(loop);
        }

        function drawLines(t) {
          const mx = mouse.x, my = mouse.y, R = mouse.radius;
          const subset = [];
          const bound = R + LINK_DIST;
          for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            if (Math.abs(p.x - mx) <= bound && Math.abs(p.y - my) <= bound) {
              subset.push(i);
            }
          }
          if (!subset.length) return;

          const g = ctx.createRadialGradient(mx, my, 0, mx, my, R * 1.2);
          g.addColorStop(0.00, 'rgba(255,225,242,0.95)');
          g.addColorStop(0.35, 'rgba(245,140,205,0.95)');
          g.addColorStop(0.70, 'rgba(222,84,175,0.93)');
          g.addColorStop(1.00, 'rgba(222,84,175,0.00)');

          ctx.globalCompositeOperation = 'screen';

          let edges = 0, EDGE_LIMIT = 700;
          for (let ai = 0; ai < subset.length; ai++) {
            const i = subset[ai], a = particles[i];
            for (let bi = ai + 1; bi < subset.length; bi++) {
              const j = subset[bi], b = particles[j];
              const dx = a.x - b.x, dy = a.y - b.y;
              const d2 = dx * dx + dy * dy;
              if (d2 > LINK_DIST2) continue;

              const dLine = segDist(mx, my, a.x, a.y, b.x, b.y);
              if (dLine >= R) continue;

              const intensity = 1 - (dLine / R);
              const dist = Math.sqrt(d2);
              const opacity = Math.min(1, (1 - dist / LINK_DIST) * (0.35 + intensity * 0.65));
              const swell = 1 + intensity * 2.0;

              ctx.lineWidth = swell * 1.7;
              ctx.strokeStyle = g;
              ctx.globalAlpha = Math.min(1, 0.10 + opacity * 0.55);
              ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();

              ctx.lineWidth = swell * 0.85;
              ctx.globalAlpha = Math.min(1, 0.20 + opacity * 0.85);
              ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();

              if (++edges > EDGE_LIMIT) break;
            }
            if (edges > EDGE_LIMIT) break;
          }

          ctx.globalAlpha = 1;
          ctx.globalCompositeOperation = 'source-over';
        }

        function segDist(px, py, x1, y1, x2, y2) {
          const dx = x2 - x1, dy = y2 - y1;
          const len2 = dx * dx + dy * dy || 1;
          let t = ((px - x1) * dx + (py - y1) * dy) / len2;
          t = Math.max(0, Math.min(1, t));
          const nx = x1 + t * dx, ny = y1 + t * dy;
          const ddx = px - nx, ddy = py - ny;
          return Math.hypot(ddx, ddy);
        }

        function enablePointer() {
          const move = (x, y) => { mouse.x = x; mouse.y = y; mouse.active = true; };
          window.addEventListener('pointermove', (e) => move(e.clientX, e.clientY));
          window.addEventListener('pointerenter', (e) => move(e.clientX, e.clientY));
          window.addEventListener('pointerdown', (e) => move(e.clientX, e.clientY));
          window.addEventListener('pointerleave', () => { mouse.active = false; });

          window.addEventListener('touchstart', (e) => {
            const t = e.touches[0]; if (t) move(t.clientX, t.clientY);
          }, { passive: true });
          window.addEventListener('touchmove', (e) => {
            const t = e.touches[0]; if (t) move(t.clientX, t.clientY);
          }, { passive: true });
          window.addEventListener('touchend', () => { mouse.active = false; });
        }

        resize(); enablePointer();
        window.addEventListener('resize', resize);
        requestAnimationFrame(loop);
      })();
    </script>
  </div>
</body>

</html>